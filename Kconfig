# Copyright (c) 2025 9p4z Contributors
# SPDX-License-Identifier: MIT

menuconfig NINEP
	bool "9P Protocol Support"
	help
	  Enable support for the 9P (Plan 9 Filesystem Protocol).
	  This allows Zephyr applications to act as 9P clients or servers
	  over various transports (UART, TCP, Bluetooth L2CAP, etc).

if NINEP

config NINEP_MAX_MESSAGE_SIZE
	int "Maximum 9P message size"
	default 8192
	help
	  Maximum size of a 9P protocol message in bytes.
	  Typical values are 8192 or 65536. Smaller values reduce
	  memory usage but may limit functionality.

config NINEP_MAX_FIDS
	int "Maximum number of file IDs (fids)"
	default 32
	help
	  Maximum number of concurrent file IDs that can be tracked.
	  Each fid represents an open file or directory handle.

config NINEP_MAX_TAGS
	int "Maximum number of pending requests"
	default 16
	help
	  Maximum number of concurrent outstanding requests.
	  Each request in flight requires a unique tag.

config NINEP_SERVER
	bool "9P Server Support"
	default y
	help
	  Enable 9P server functionality.

if NINEP_SERVER

config NINEP_FS_PASSTHROUGH
	bool "Passthrough Filesystem Backend"
	depends on FILE_SYSTEM
	help
	  Enable passthrough filesystem backend that exposes any mounted
	  Zephyr filesystem (LittleFS, FAT, etc.) via 9P.

	  This allows exposing real storage (flash, SD card) as a
	  "Bluetooth hard drive" or network file share.

	  Example uses:
	  - Expose LittleFS partition on internal flash
	  - Share SD card contents over Bluetooth L2CAP
	  - Remote file access over TCP/IP

config NINEP_DFU
	bool "9P DFU (Device Firmware Update)"
	depends on IMG_MANAGER
	depends on FLASH_MAP
	help
	  Enable firmware update via 9P filesystem.

	  Exposes /dev/firmware (or custom path) as a sysfs file that
	  accepts MCUboot firmware images. The module handles:
	  - Pre-erasing secondary slot on first write
	  - Buffered streaming writes to flash
	  - Image validation on file close
	  - Marking image for test upgrade

	  Usage from a 9P client:
	    cat firmware.bin | 9p write /dev/firmware
	    9p read /dev/firmware  # check status

	  After upload, reboot to apply. Call ninep_dfu_confirm()
	  from application code to make the update permanent.

endif # NINEP_SERVER

config NINEP_CLIENT
	bool "9P Client Support"
	default y
	help
	  Enable 9P client functionality.

config NINEP_TRANSPORT_UART
	bool "UART Transport"
	depends on SERIAL
	help
	  Enable 9P over UART serial transport.

if NINEP_TRANSPORT_UART

config NINEP_UART_POLLING_MODE
	bool "Use UART polling mode instead of interrupts"
	default n
	help
	  Use UART polling for receive instead of interrupt-driven mode.
	  Polling mode is less efficient but works on platforms where
	  UART interrupts are not properly configured.

endif # NINEP_TRANSPORT_UART

config NINEP_TRANSPORT_TCP
	bool "TCP Transport"
	depends on NETWORKING
	help
	  Enable 9P over TCP/IP transport.

	  When CONFIG_NET_IPV6 is enabled, operates in dual-stack mode,
	  accepting both native IPv6 and IPv4-mapped IPv6 connections.

	  When CONFIG_NET_IPV6 is disabled, operates in IPv4-only mode.

config NINEP_TRANSPORT_L2CAP
	bool "Bluetooth L2CAP Transport"
	depends on BT_L2CAP_DYNAMIC_CHANNEL
	help
	  Enable 9P over Bluetooth L2CAP transport.

if NINEP_TRANSPORT_L2CAP

config NINEP_L2CAP_PSM
	hex "L2CAP PSM for 9P service"
	default 0x0009
	help
	  Protocol/Service Multiplexer (PSM) for the 9P L2CAP service.
	  Default: 0x0009 (well-known PSM, matches iOS implementation).
	  Can also use dynamic range (0x0080-0x00FF) if needed.

config NINEP_L2CAP_MTU
	int "Maximum L2CAP MTU"
	default 4096
	range 23 65535
	help
	  Maximum L2CAP MTU (Maximum Transmission Unit) in bytes.
	  The actual MTU will be negotiated with the peer.
	  Typical values are 512, 1024, 2048, or 4096.
	  Default: 4096 bytes.

endif # NINEP_TRANSPORT_L2CAP

config NINEP_TRANSPORT_L2CAP_CLIENT
	bool "Bluetooth L2CAP Client Transport"
	depends on BT_L2CAP_DYNAMIC_CHANNEL && BT_CENTRAL
	help
	  Enable 9P client over Bluetooth L2CAP transport.

	  This transport operates in CLIENT mode, initiating a BLE connection
	  to a 9P server and establishing an L2CAP channel for communication.

	  Two connection modes are supported:
	  - Direct connect: Connect to a known device address
	  - Scan and connect: Scan for devices advertising a specific service UUID

	  Use this when your Zephyr device needs to connect to a remote 9P server
	  over Bluetooth, for example connecting to a keyboard or sensor that
	  exports data via 9P.

	  Requires CONFIG_BT_CENTRAL for initiating BLE connections.

config NINEP_TRANSPORT_COAP
	bool "CoAP Transport (Server Mode)"
	depends on NETWORKING && COAP
	help
	  Enable 9P over CoAP (Constrained Application Protocol) transport
	  in SERVER mode.

	  The device acts as a CoAP server, listening for incoming 9P requests.
	  This transport tunnels 9P messages over CoAP using confirmable (CON)
	  messages for reliable delivery over UDP. Large messages are handled
	  using RFC 7959 block-wise transfer when they exceed the CoAP MTU.

	  Use this for LAN scenarios where the device is directly reachable.

	  Ideal for constrained networks such as Thread/6LoWPAN where CoAP
	  infrastructure already exists.

config NINEP_TRANSPORT_COAP_CLIENT
	bool "CoAP Transport (Client Mode)"
	depends on NETWORKING && COAP
	select COAP_CLIENT
	help
	  Enable 9P over CoAP transport in CLIENT mode with NAT traversal.

	  The device acts as a CoAP client, connecting to a cloud-hosted CoAP
	  server. It uses CoAP Observe (RFC 7641) to receive 9P requests from
	  the cloud as push notifications.

	  This enables remote access to devices behind NAT/firewalls without
	  port forwarding. The device initiates the connection, and the cloud
	  sends requests via Observe notifications.

	  Architecture:
	    [Device] --Observe--> [Cloud CoAP Server] <--9P--> [Remote Users]

	  Use cases:
	    - Device behind home/office NAT
	    - Remote access from anywhere
	    - IoT cloud platforms
	    - Mobile app gateway scenarios

config NINEP_GATT_9PIS
	bool "9P Information Service (9PIS) GATT Service"
	depends on BT_GATT_DYNAMIC_DB || BT
	help
	  Enable the 9P Information Service (9PIS) GATT service.
	  This service provides discoverability and metadata about
	  available 9P services on the device. When enabled, clients
	  can read service information including:
	  - Service description
	  - Available features
	  - Transport connection details
	  - App download link
	  - Protocol version

	  This is particularly useful for mobile apps to discover
	  and connect to 9P servers over Bluetooth.

module = NINEP
module-str = 9p
source "subsys/logging/Kconfig.template.log_config"

menuconfig NAMESPACE
	bool "Plan 9-style Namespace Support"
	depends on FILE_SYSTEM
	help
	  Enable per-thread composable namespaces with union mount semantics.
	  Provides Plan 9-style namespace manipulation on top of Zephyr VFS.

	  This allows threads to have customized views of the filesystem
	  hierarchy, with support for union mounts, network transparency via 9P,
	  and namespace inheritance.

if NAMESPACE

config NS_MAX_PATH_LEN
	int "Maximum path length"
	default 256
	help
	  Maximum length of a filesystem path in the namespace.

config NS_HASH_SIZE
	int "Namespace hash table size"
	default 32
	help
	  Size of hash table for namespace entries.
	  Larger values improve lookup performance but use more memory.

config NS_MAX_MOUNTS_PER_THREAD
	int "Maximum mounts per thread"
	default 16
	help
	  Maximum number of mount points in a single thread's namespace.

config NS_MAX_UNION_DEPTH
	int "Maximum union mount depth"
	default 8
	help
	  Maximum number of filesystems that can be unioned at a single path.

config NS_ENABLE_COW
	bool "Enable copy-on-write namespace inheritance"
	default y
	help
	  When enabled, child threads inherit parent namespace via COW.
	  Disable to save memory if namespace inheritance is not needed.

config NS_THREAD_LOCAL_STORAGE
	bool "Use thread-local storage for namespace"
	depends on THREAD_LOCAL_STORAGE
	default y
	help
	  Store current namespace pointer in TLS for fast access.
	  If disabled, uses hash table lookup (slower but works without TLS).

config NS_DEBUG
	bool "Enable namespace debugging"
	default n
	help
	  Enable verbose debug logging for namespace operations.

config NINEP_VFS
	bool "9P VFS Driver"
	depends on NINEP_CLIENT
	default y
	help
	  Enable 9P VFS driver that registers 9P as a Zephyr filesystem type.
	  This allows 9P filesystems to be mounted using the standard VFS API.

config SRV_REGISTRY
	bool "Service registry (/srv)"
	default y
	help
	  Enable the /srv service registry filesystem.
	  Services can post themselves to /srv for discovery and connection.

if SRV_REGISTRY

config SRV_MAX_SERVICES
	int "Maximum number of services in /srv"
	default 32
	help
	  Maximum number of services that can be registered in /srv.

config SRV_MAX_NAME_LEN
	int "Maximum service name length"
	default 64
	help
	  Maximum length of a service name in /srv.

endif # SRV_REGISTRY

endif # NAMESPACE

endif # NINEP