# Copyright (c) 2025 9p4z Contributors
# SPDX-License-Identifier: MIT

menuconfig NINEP
	bool "9P Protocol Support"
	help
	  Enable support for the 9P (Plan 9 Filesystem Protocol).
	  This allows Zephyr applications to act as 9P clients or servers
	  over various transports (UART, TCP, Bluetooth L2CAP, etc).

if NINEP

config NINEP_MAX_MESSAGE_SIZE
	int "Maximum 9P message size"
	default 8192
	help
	  Maximum size of a 9P protocol message in bytes.
	  Typical values are 8192 or 65536. Smaller values reduce
	  memory usage but may limit functionality.

config NINEP_MAX_FIDS
	int "Maximum number of file IDs (fids)"
	default 32
	help
	  Maximum number of concurrent file IDs that can be tracked.
	  Each fid represents an open file or directory handle.

config NINEP_MAX_TAGS
	int "Maximum number of pending requests"
	default 16
	help
	  Maximum number of concurrent outstanding requests.
	  Each request in flight requires a unique tag.

config NINEP_SERVER
	bool "9P Server Support"
	default y
	help
	  Enable 9P server functionality.

if NINEP_SERVER

config NINEP_FS_PASSTHROUGH
	bool "Passthrough Filesystem Backend"
	depends on FILE_SYSTEM
	help
	  Enable passthrough filesystem backend that exposes any mounted
	  Zephyr filesystem (LittleFS, FAT, etc.) via 9P.

	  This allows exposing real storage (flash, SD card) as a
	  "Bluetooth hard drive" or network file share.

	  Example uses:
	  - Expose LittleFS partition on internal flash
	  - Share SD card contents over Bluetooth L2CAP
	  - Remote file access over TCP/IP

endif # NINEP_SERVER

config NINEP_CLIENT
	bool "9P Client Support"
	default y
	help
	  Enable 9P client functionality.

config NINEP_TRANSPORT_UART
	bool "UART Transport"
	depends on SERIAL
	help
	  Enable 9P over UART serial transport.

if NINEP_TRANSPORT_UART

config NINEP_UART_POLLING_MODE
	bool "Use UART polling mode instead of interrupts"
	default n
	help
	  Use UART polling for receive instead of interrupt-driven mode.
	  Polling mode is less efficient but works on platforms where
	  UART interrupts are not properly configured.

endif # NINEP_TRANSPORT_UART

config NINEP_TRANSPORT_TCP
	bool "TCP Transport"
	depends on NETWORKING
	help
	  Enable 9P over TCP/IP transport.

	  When CONFIG_NET_IPV6 is enabled, operates in dual-stack mode,
	  accepting both native IPv6 and IPv4-mapped IPv6 connections.

	  When CONFIG_NET_IPV6 is disabled, operates in IPv4-only mode.

config NINEP_TRANSPORT_L2CAP
	bool "Bluetooth L2CAP Transport"
	depends on BT_L2CAP_DYNAMIC_CHANNEL
	help
	  Enable 9P over Bluetooth L2CAP transport.

if NINEP_TRANSPORT_L2CAP

config NINEP_L2CAP_PSM
	hex "L2CAP PSM for 9P service"
	default 0x0009
	help
	  Protocol/Service Multiplexer (PSM) for the 9P L2CAP service.
	  Default: 0x0009 (well-known PSM, matches iOS implementation).
	  Can also use dynamic range (0x0080-0x00FF) if needed.

config NINEP_L2CAP_MTU
	int "Maximum L2CAP MTU"
	default 4096
	range 23 65535
	help
	  Maximum L2CAP MTU (Maximum Transmission Unit) in bytes.
	  The actual MTU will be negotiated with the peer.
	  Typical values are 512, 1024, 2048, or 4096.
	  Default: 4096 bytes.

endif # NINEP_TRANSPORT_L2CAP

config NINEP_TRANSPORT_COAP
	bool "CoAP Transport (Server Mode)"
	depends on NETWORKING && COAP
	help
	  Enable 9P over CoAP (Constrained Application Protocol) transport
	  in SERVER mode.

	  The device acts as a CoAP server, listening for incoming 9P requests.
	  This transport tunnels 9P messages over CoAP using confirmable (CON)
	  messages for reliable delivery over UDP. Large messages are handled
	  using RFC 7959 block-wise transfer when they exceed the CoAP MTU.

	  Use this for LAN scenarios where the device is directly reachable.

	  Ideal for constrained networks such as Thread/6LoWPAN where CoAP
	  infrastructure already exists.

config NINEP_TRANSPORT_COAP_CLIENT
	bool "CoAP Transport (Client Mode)"
	depends on NETWORKING && COAP
	select COAP_CLIENT
	help
	  Enable 9P over CoAP transport in CLIENT mode with NAT traversal.

	  The device acts as a CoAP client, connecting to a cloud-hosted CoAP
	  server. It uses CoAP Observe (RFC 7641) to receive 9P requests from
	  the cloud as push notifications.

	  This enables remote access to devices behind NAT/firewalls without
	  port forwarding. The device initiates the connection, and the cloud
	  sends requests via Observe notifications.

	  Architecture:
	    [Device] --Observe--> [Cloud CoAP Server] <--9P--> [Remote Users]

	  Use cases:
	    - Device behind home/office NAT
	    - Remote access from anywhere
	    - IoT cloud platforms
	    - Mobile app gateway scenarios

config NINEP_GATT_9PIS
	bool "9P Information Service (9PIS) GATT Service"
	depends on BT_GATT_DYNAMIC_DB || BT
	help
	  Enable the 9P Information Service (9PIS) GATT service.
	  This service provides discoverability and metadata about
	  available 9P services on the device. When enabled, clients
	  can read service information including:
	  - Service description
	  - Available features
	  - Transport connection details
	  - App download link
	  - Protocol version

	  This is particularly useful for mobile apps to discover
	  and connect to 9P servers over Bluetooth.

module = NINEP
module-str = 9p
source "subsys/logging/Kconfig.template.log_config"

endif # NINEP